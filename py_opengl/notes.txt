# Sphere

@dataclass(eq=False, repr=False, slots=True)
class Sphere:
    radius: float = 1.0
    r_segments: int = 16
ii    h_segments: int = 8
    data_size: int = 1
    components: int = 3
    verts: list[float] = field(default_factory=list)
    color: list[float] = field(default_factory=list)


def sphere_init(s: Sphere) -> None:
    ''' '''
    ustart: float = 0
    uend: float = glm.TAU
    ures: float = s.r_segments
    vstart: float = -glm.PIOVER2
    vend: float = glm.PIOVER2
    vres: float = s.h_segments

    udelta: float = (uend - ustart) / ures
    vdelta: float = (vend - vstart) / vres

    c1, c2, c3 = [1, 0, 0], [0, 1, 0], [0, 0, 1]
    c4, c5, c6 = [0, 1, 1], [1, 0, 1], [1, 1, 0]

    p = []  # list[list[list[float]]]
    for i in range(ures+1):
        a = []
        for j in range(vres+1):
            u: float = ustart + i * udelta
            v: float = vstart + j * vdelta

            cu: float = glm.cos(u)
            cv: float = glm.cos(v)
            su: float = glm.sin(u)
            sv: float = glm.sin(v)
            res = [
                    s.radius * su * cv,
                    s.radius * sv,
                    s.radius * cu * cv]
            a.append(res)
        p.append(a)

    for i in range(ures):
        for j in range(vres):
            a = p[i+0][j+0]
            b = p[i+1][j+0]
            c = p[i+0][j+1]
            d = p[i+1][j+1]

            s.verts += a
            s.verts += b
            s.verts += d
            s.verts += a
            s.verts += d
            s.verts += c

            s.color += c1
            s.color += c2
            s.color += c3
            s.color += c4
            s.color += c5
            s.color += c6

    s.data_size = len(s.verts)



# ---


@dataclass(eq=False, repr=False, slots=True)
class Cube:
    width: float = 1.0
    height: float = 1.0
    depth: float = 1.0
    verts: list[float] = field(default_factory=list)
    color: list[float] = field(default_factory=list)
    data_size: int = 108
    components: int = 3


def cube_init(c: Cube) -> None:
    wp: float = c.width * 0.5
    hp: float = c.height * 0.5
    dp: float = c.depth * 0.5

    wn: float = wp * -1.0
    hn: float = hp * -1.0
    dn: float = dp * -1.0

    c.verts = [
            wp, hn, dp, wp, hn, dn, wp, hp, dn,
            wp, hn, dp, wp, hp, dn, wp, hp, dp,
            wn, hn, dn, wn, hn, dp, wn, hp, dp,
            wn, hn, dn, wn, hp, dp, wn, hp, dn,
            wn, hp, dp, wp, hp, dp, wp, hp, dn,
            wn, hp, dp, wp, hp, dn, wn, hp, dn,
            wn, hn, dn, wp, hn, dn, wp, hn, dp,
            wn, hn, dn, wp, hn, dp, wn, hn, dp,
            wn, hn, dp, wp, hn, dp, wp, hp, dp,
            wn, hn, dp, wp, hp, dp, wn, hp, dp,
            wp, hn, dn, wn, hn, dn, wn, hp, dn,
            wp, hn, dn, wn, hp, dn, wp, hp, dn]

    c.color = [
        1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
        0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
        0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
        0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
        0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
        0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
        0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0]


# --- VBO

@dataclass(eq=False, repr=False, slots=True)
class Vbo:
    vao: int = 0
    data_size: int = 1      # len of data passed in
    components: int = 3     # x y z
    normalized: bool = False
    vbos: list[int] = field(default_factory=list)

    def __post_init__(self):
        self.vao = gl.glGenVertexArrays(1)


def vbo_draw(vbo: Vbo) -> None:
    '''Bind vbo to vertex Array'''
    count = vbo.data_size // vbo.components
    if count <= 0:
        return
    gl.glBindVertexArray(vbo.vao)
    gl.glDrawArrays(gl.GL_TRIANGLES, 0, count)


def vbo_clean(vbo: Vbo) -> None:
    '''Clean vbo'''
    gl.glDeleteVertexArrays(1, vbo.vao)
    for v in vbo.vbos:
        gl.glDeleteBuffers(1, v)


def vbo_add_data(vbo: Vbo, arr: list[float]) -> None:
    '''Add data to vbo'''
    v_buffer = gl.glGenBuffers(1)
    gl.glBindBuffer(gl.GL_ARRAY_BUFFER, v_buffer)
    gl.glBindVertexArray(vbo.vao)
    vbo.vbos.append(v_buffer)
    normal = gl.GL_TRUE if vbo.normalized else gl.GL_FALSE

    gl.glBufferData(
            gl.GL_ARRAY_BUFFER,
            len(arr) * FLOAT_SIZE,
            c_array(arr),
            gl.GL_STATIC_DRAW)

    at = len(vbo.vbos) - 1
    gl.glVertexAttribPointer(
            at,
            vbo.components,
            gl.GL_FLOAT,
            normal,
            0,
            NULL_PTR)
    gl.glEnableVertexAttribArray(at)



# --- SHADER


@dataclass(eq=False, repr=False, slots=True)
class Shader:
    program_id: int = 0

    def __post_init__(self):
        self.program_id = gl.glCreateProgram()


def shader_default(shader: Shader) -> None:
    '''Simple shader
    '''
    p = Path('./py_opengl')
    vp = p / 'default.vert'
    fp = p / 'default.frag'

    if not vp.exists() or not fp.exists():
        raise FileNotFoundError('ever frag or vert files were not found')

    with (
            vp.open(mode='rb') as v,
            fp.open(mode='rb') as f):
        vert = v.read()
        frag = f.read()

        shader.program_id = compileProgram(
            compileShader(vert, gl.GL_VERTEX_SHADER),
            compileShader(frag, gl.GL_FRAGMENT_SHADER)
        )


def shader_clean(shader: Shader) -> None:
    '''Delete shader program id'''
    gl.glDeleteProgram(shader.program_id)


def shader_use(shader: Shader) -> None:
    '''Use shader program id'''
    gl.glUseProgram(shader.program_id)


def shader_set_vec3(shader: Shader, var_name: str, data: glm.Vec3) -> None:
    '''Set a global uniform vec3 variable within shader program'''
    location_id = gl.glGetUniformLocation(shader.program_id, var_name)

    gl.glUniform3f(location_id, data.x, data.y, data.z)


def shader_set_m4(shader: Shader, var_name: str, data: glm.Mat4) -> None:
    '''Set a global uniform mat4 variable within shader program'''
    location_id = gl.glGetUniformLocation(shader.program_id, var_name)

    gl.glUniformMatrix4fv(
            location_id,
            1,
            gl.GL_FALSE,
            glm.m4_to_multi_array(data))



